// 预解释是毫无节操的一种机制
// 自从学了预解释，从此节操是路人

// 1、预解释的时候，不管你的条件是否成立，都要把带var的进行提前的声明
// window的预解释：var num; -> 相当于window.num;
// if (!('num' in window)) {
//     var num =12;
// }
// console.log(num); //->undefined

// 2、匿名函数之函数表达式： 把函数定义的部分当做一个之赋值给一个变量
// 那么它是怎样进行预解释的呢？首先看下面的代码，左边是变量，右边是值，右边的值不参与预解释
// fn(); // -> Uncaught TypeError: fn is not a function
// var fn = function () {
//     console.log('ok');
// };
/*注意上下区别*/
// fn1(); // -> fn01
// function fn1() {
//     console.log('fn01');
// }
// fn1(); // -> fn01

// 总结： 用函数表达式来定义函数会好一点，因为在预解释的时候，只声明，不定义，
// 这就意味着想要执行函数表达式，就必须要在声明函数下进行。
// 另外一点是调试的时候好调试


/*-----------------------------------------------------------------------*/
// 3、立即执行函数：定义和执行一起完成
// 立即执行函数不进行预解释！！！！
// 这些function前的奇怪符号作用是为了符合语法的。因为预解释，凡是带function开头的函数，都需要预解释（声明+定义）
// console.log('haha');
// ~function (num) {
//     console.log(num)
// }(10);
//

/*-----------------------------------------------------------------------*/
// 4、函数体中return下面的代码虽然不在执行了，但是还是需要预解释的。
// 值得注意的是，return 后面的值是返回值，所以不进行预解释！！！！
// function fn() {
//     // 预解释：var num;
//     console.log(num); // -> undefined
//     return function () {};
//     var num = 100;
// }
// fn();


/*-----------------------------------------------------------------------*/
// 5、在预解释的时候，如果名字已经声明过，不需要再次重新声明，但需要重新赋值；
// 在JS中如果变量的名字和函数的名字重复，也算冲突，新的会覆盖的旧的。
// 预解释： var fn； window.fn; fn = xxfff000; window.fn = xxxfff000;
// var fn = 13;
// function fn() {
//     console.log('ok');
// }
//
fn(); // -> 2
function fn() {console.log(1);}
fn(); // -> 2
var fn = 0; // 预解释中，如果名字声明过了，就不用重新声明，但是要重新赋值
fn(); // -> Uncaught TypeError: fn is not a function
function fn() {console.log(2);} // -> 不执行
fn(); // -> 不执行

// 上面这行代码的window预解释如下：
// 声明+定义 fn = xxxfff111
// 声明 var fn;(不需要重新声明，这步js直接忽略掉)
// 声明（不重复进行）+定义 fn = xxxfff222